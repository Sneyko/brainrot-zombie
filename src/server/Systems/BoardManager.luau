--!strict

--[[
	BoardManager (ModuleScript)
	Gestion des unit√©s d√©fensives plac√©es sur le sol.
	Plus de grille ‚Äî les unit√©s sont clon√©es depuis Assets et plac√©es librement.
	Accessible depuis : ServerScriptService.Server.Systems.BoardManager
]]

-- Services
local Workspace: Workspace = game:GetService("Workspace")
local ReplicatedStorage: ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Modules
local sharedFolder: Instance = ReplicatedStorage:WaitForChild("Shared")
local Constants = require(sharedFolder:WaitForChild("Constants"))
local UnitDatabase = require(sharedFolder:WaitForChild("Data"):WaitForChild("UnitDatabase"))

-- Dossier Assets (mod√®les 3D des brainrot)
local assetsFolder: Folder = ReplicatedStorage:WaitForChild("Assets") :: Folder

-------------------------------------------------
-- Types
-------------------------------------------------
export type PlacedUnit = {
	Id: number,
	UnitId: string,       -- Cl√© dans UnitDatabase (ex: "Glorbo")
	Owner: Player?,
	Model: Model,         -- Mod√®le 3D clon√© depuis Assets
	Position: Vector3,    -- Position world (centre au sol)
}

-------------------------------------------------
-- Module
-------------------------------------------------
local BoardManager = {}

BoardManager.PlacedUnits = {} :: { [number]: PlacedUnit }
local nextUnitId: number = 0

-------------------------------------------------
-- Placement d'unit√© (clone depuis Assets)
-------------------------------------------------

--- Place une unit√© sur le sol en clonant le mod√®le depuis Assets
function BoardManager.PlaceUnit(unitId: string, position: Vector3, owner: Player?): number
	local unitData = UnitDatabase[unitId]
	if unitData == nil then
		warn(`[BoardManager] ‚ùå Unit√© inconnue : "{unitId}"`)
		return -1
	end

	if unitData.Type ~= "Plant" then
		warn(`[BoardManager] ‚ùå "{unitId}" n'est pas une unit√© d√©fensive`)
		return -1
	end

	-- Chercher le mod√®le dans Assets
	local templateName: string = `Unit_{unitId}`
	local template: Instance? = assetsFolder:FindFirstChild(templateName)
	if template == nil then
		warn(`[BoardManager] ‚ùå Asset introuvable : {templateName}`)
		return -1
	end

	-- Cloner le mod√®le
	local model: Model = template:Clone() :: Model

	nextUnitId += 1
	local id: number = nextUnitId
	model.Name = `PlacedUnit_{unitId}_{id}`

	-- Uniformiser la taille (tous √† UNIT_MODEL_HEIGHT studs de haut)
	local scaleOk: boolean, scaleErr: string? = pcall(function(): ()
		local _, origSize: Vector3 = model:GetBoundingBox()
		local currentHeight: number = origSize.Y
		if currentHeight > 0 then
			local currentScale: number = model:GetScale()
			local scaleFactor: number = (Constants.UNIT_MODEL_HEIGHT / currentHeight) * currentScale
			model:ScaleTo(scaleFactor)
			print(`[BoardManager] üìê {unitId} ‚Äî hauteur orig: {math.floor(currentHeight)} ‚Üí cible: {Constants.UNIT_MODEL_HEIGHT} (scale: {string.format("%.3f", scaleFactor)})`)
		else
			warn(`[BoardManager] ‚ö†Ô∏è {unitId} ‚Äî bounding box vide (pas de BasePart ?)`)
		end
	end)
	if not scaleOk then
		warn(`[BoardManager] ‚ö†Ô∏è Erreur scale {unitId}: {scaleErr or "inconnue"}`)
	end

	-- Recalculer apr√®s mise √† l'√©chelle
	local _, size: Vector3 = model:GetBoundingBox()
	local groundY: number = Constants.GROUND_TOP_Y + size.Y / 2
	local spawnPos: Vector3 = Vector3.new(position.X, groundY, position.Z)

	-- Positionner face aux zombies (+Z = direction d'o√π viennent les zombies)
	local lookTarget: Vector3 = spawnPos + Vector3.new(0, 0, 1)
	model:PivotTo(CFrame.lookAt(spawnPos, lookTarget))
	
	-- Ancrer toutes les parts 
	for _, descendant: Instance in model:GetDescendants() do
		if descendant:IsA("BasePart") then
			(descendant :: BasePart).Anchored = true
			(descendant :: BasePart).CanCollide = false
		end
	end

	-- Placer dans le dossier GameBoard
	local gameBoard: Instance? = Workspace:FindFirstChild("GameBoard")
	model.Parent = if gameBoard then gameBoard else Workspace

	local unit: PlacedUnit = {
		Id = id,
		UnitId = unitId,
		Owner = owner,
		Model = model,
		Position = spawnPos,
	}

	BoardManager.PlacedUnits[id] = unit

	print(`[BoardManager] ‚úÖ {unitData.Name} plac√© (ID:{id}) √† ({math.floor(spawnPos.X)}, {math.floor(spawnPos.Z)})`)
	return id
end

-------------------------------------------------
-- Suppression d'unit√©
-------------------------------------------------

--- Supprime une unit√© plac√©e
function BoardManager.RemoveUnit(id: number): ()
	local unit: PlacedUnit? = BoardManager.PlacedUnits[id]
	if unit == nil then return end

	if unit.Model then
		unit.Model:Destroy()
	end

	BoardManager.PlacedUnits[id] = nil
	print(`[BoardManager] üóëÔ∏è Unit√© {id} supprim√©e`)
end

--- Retourne le nombre d'unit√©s plac√©es
function BoardManager.GetPlacedCount(): number
	local count: number = 0
	for _ in BoardManager.PlacedUnits do
		count += 1
	end
	return count
end

print("[BoardManager] ‚úÖ BoardManager initialis√© (mode liste)")

return BoardManager
