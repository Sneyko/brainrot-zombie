--!strict

--[[
	GameLoop (ServerScript)
	Tower Defense temps r√©el ‚Äî WaveManager + √©conomie BrainCoin.
	Placement via plaques Touched sur le mur.
	Accessible depuis : ServerScriptService.Server.GameLoop
]]

-- Services
local Players: Players = game:GetService("Players")
local Workspace: Workspace = game:GetService("Workspace")
local ReplicatedStorage: ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Modules
local sharedFolder: Instance = ReplicatedStorage:WaitForChild("Shared")
local Constants = require(sharedFolder:WaitForChild("Constants"))
local BoardManager = require(script.Parent:WaitForChild("Systems"):WaitForChild("BoardManager"))
local UnitDatabase = require(sharedFolder:WaitForChild("Data"):WaitForChild("UnitDatabase"))
local ZombieSpawner = require(script.Parent:WaitForChild("Systems"):WaitForChild("ZombieSpawner"))
local CombatSystem = require(script.Parent:WaitForChild("Systems"):WaitForChild("CombatSystem"))

-- Initialiser le CombatSystem
CombatSystem.Init(BoardManager, ZombieSpawner)

-- RemoteEvents
local eventsFolder: Folder = sharedFolder:WaitForChild("Events") :: Folder
local budgetUpdateEvent: RemoteEvent = eventsFolder:WaitForChild("BudgetUpdate") :: RemoteEvent

-- Constantes
local MIN_PLAYERS: number = 1
local PLATE_DEBOUNCE: number = 2  -- Secondes entre deux achats par joueur

-- RNG
local rng: Random = Random.new()

-- Types de zombies
local ZOMBIE_TYPES: { string } = { "BasicSkibidi", "BasicZombie" }
local ELITE_ZOMBIE: string = "NikeShark"
local ELITE_WAVE_INTERVAL: number = 3

-------------------------------------------------
-- √âtat du jeu
-------------------------------------------------
local playerBrainCoin: number = Constants.STARTING_BRAINCOIN
local baseHP: number = Constants.BASE_HP
local currentWave: number = 0
local gameOver: boolean = false

-- Debounce par joueur+plaque ("UserId_UnitId" ‚Üí temps du dernier achat)
local plateDebounce: { [string]: number } = {}

-------------------------------------------------
-- Helpers
-------------------------------------------------

local function waitForPlayers(): ()
	print("[GameLoop] ‚è≥ En attente de joueurs...")
	while #Players:GetPlayers() < MIN_PLAYERS do
		task.wait(1)
	end
	print(`[GameLoop] ‚úÖ {#Players:GetPlayers()} joueur(s) connect√©(s) ‚Äî D√©marrage !`)
end

local function broadcastBrainCoin(): ()
	budgetUpdateEvent:FireAllClients(playerBrainCoin, baseHP)
end

local function addBrainCoin(amount: number): ()
	playerBrainCoin += amount
	broadcastBrainCoin()
end

-------------------------------------------------
-- Callbacks ZombieSpawner
-------------------------------------------------

ZombieSpawner.OnZombieDied = function(zombie)
	print(`[GameLoop] üíÄ Zombie {zombie.UnitId} (ID:{zombie.Id}) tu√© ! +{Constants.KILL_REWARD} BrainCoin`)
	addBrainCoin(Constants.KILL_REWARD)
end

ZombieSpawner.OnZombieReachedEnd = function(zombie)
	baseHP -= zombie.Damage
	print(`[GameLoop] üè† Base touch√©e ! -{zombie.Damage} HP ‚Üí {baseHP}/{Constants.BASE_HP}`)
	broadcastBrainCoin()

	if baseHP <= 0 and not gameOver then
		gameOver = true
		warn(`[GameLoop] üíÄ GAME OVER ‚Äî La base est d√©truite ! (Vague {currentWave})`)
	end
end

-------------------------------------------------
-- Placement via Touched (plaques sur le mur)
-------------------------------------------------

--- Remonte l'arborescence pour trouver le Character (g√®re Accessories)
local function getCharacterFromPart(part: BasePart): Model?
	local current: Instance? = part.Parent
	while current do
		if current:IsA("Model") and current:FindFirstChildOfClass("Humanoid") then
			return current :: Model
		end
		current = current.Parent
	end
	return nil
end

--- Connecte les √©v√©nements Touched sur les 4 plaques d'achat
local function setupPlates(): ()
	local gameBoard: Folder = Workspace:WaitForChild("GameBoard") :: Folder

	for _, unitId: string in Constants.PLANT_UNITS do
		local plateName: string = `Plate_{unitId}`
		local plate: Part? = gameBoard:FindFirstChild(plateName) :: Part?
		if plate == nil then
			warn(`[GameLoop] ‚ö†Ô∏è Plaque introuvable : {plateName}`)
			continue
		end

		plate.Touched:Connect(function(otherPart: BasePart): ()
			if gameOver then return end

			-- Trouver le Character (g√®re accessoires + body parts)
			local character: Model? = getCharacterFromPart(otherPart)
			if character == nil then return end

			local player: Player? = Players:GetPlayerFromCharacter(character)
			if player == nil then return end

			-- Debounce par joueur + plaque
			local debounceKey: string = `{player.UserId}_{unitId}`
			local now: number = tick()
			local lastBuy: number = plateDebounce[debounceKey] or 0
			if (now - lastBuy) < PLATE_DEBOUNCE then return end

			-- V√©rifier donn√©es de l'unit√©
			local unitData = UnitDatabase[unitId]
			if unitData == nil then
				warn(`[GameLoop] ‚ö†Ô∏è UnitDatabase["{unitId}"] introuvable`)
				return
			end

			-- V√©rifier BrainCoin
			local cost: number = unitData.Cost
			if playerBrainCoin < cost then
				print(`[GameLoop] ‚ùå BrainCoin insuffisant pour {unitData.Name} : {playerBrainCoin}/{cost}`)
				return
			end

			-- Debounce activ√©
			plateDebounce[debounceKey] = now

			-- D√©duire le co√ªt
			playerBrainCoin -= cost
			broadcastBrainCoin()

			-- Position de spawn sur le sol (al√©atoire dans la zone)
			local spawnX: number = Constants.WALL_POSITION.X + rng:NextNumber(
				-Constants.UNIT_SPAWN_X_SPREAD,
				Constants.UNIT_SPAWN_X_SPREAD
			)
			local spawnZ: number = rng:NextNumber(
				Constants.UNIT_SPAWN_Z_MIN,
				Constants.UNIT_SPAWN_Z_MAX
			)
			local spawnPos: Vector3 = Vector3.new(spawnX, Constants.GROUND_TOP_Y, spawnZ)

			print(`[GameLoop] üîß Spawn {unitData.Name} √† ({math.floor(spawnX)}, {Constants.GROUND_TOP_Y}, {math.floor(spawnZ)})`)

			-- Placer l'unit√© sur le sol (clone depuis Assets)
			local unitIdResult: number = BoardManager.PlaceUnit(unitId, spawnPos, player)

			if unitIdResult < 0 then
				-- Rembourser si √©chec
				playerBrainCoin += cost
				broadcastBrainCoin()
				warn(`[GameLoop] ‚ùå √âchec placement {unitData.Name}`)
				return
			end

			print(`[GameLoop] üß† {unitData.Name} achet√© ! BrainCoin restant : {playerBrainCoin} (-{cost})`)
		end)

		print(`[GameLoop] üîó Plaque connect√©e : {plateName}`)
	end
end

-------------------------------------------------
-- Syst√®me de vagues
-------------------------------------------------

local function spawnWave(waveNumber: number): ()
	local zombieCount: number = Constants.BASE_ZOMBIES_PER_WAVE + (waveNumber - 1) * Constants.ZOMBIES_INCREMENT

	print(`[GameLoop] üåä VAGUE {waveNumber} ‚Äî {zombieCount} zombie(s)`)

	for i = 1, zombieCount do
		if gameOver then break end

		local zombieType: string
		if waveNumber >= ELITE_WAVE_INTERVAL and i == zombieCount and waveNumber % ELITE_WAVE_INTERVAL == 0 then
			zombieType = ELITE_ZOMBIE
		else
			zombieType = ZOMBIE_TYPES[rng:NextInteger(1, #ZOMBIE_TYPES)]
		end

		ZombieSpawner.SpawnZombie(zombieType)

		if i < zombieCount then
			task.wait(Constants.WAVE_SPAWN_INTERVAL)
		end
	end
end

local function waitForWaveEnd(): ()
	while ZombieSpawner.GetActiveCount() > 0 and not gameOver do
		task.wait(0.5)
	end
end

-------------------------------------------------
-- Boucle principale
-------------------------------------------------
print("[GameLoop] üéÆ GameLoop d√©marr√©e (Tower Defense ‚Äî plaques d'achat)")

task.spawn(function(): ()
	waitForPlayers()

	-- Connecter les plaques d'achat
	setupPlates()

	-- Broadcast BrainCoin initiaux
	broadcastBrainCoin()

	-- D√©marrer le CombatSystem
	CombatSystem.Start()

	-- Pause initiale
	print("[GameLoop] ‚è≥ Premi√®re vague dans 5 secondes...")
	task.wait(5)

	-- Boucle de vagues
	while not gameOver do
		currentWave += 1
		spawnWave(currentWave)
		waitForWaveEnd()

		if gameOver then break end

		print(`[GameLoop] üèÜ Vague {currentWave} termin√©e ! +{Constants.WAVE_BONUS} BrainCoin bonus`)
		addBrainCoin(Constants.WAVE_BONUS)

		print(`[GameLoop] ‚è∏Ô∏è Prochaine vague dans {Constants.WAVE_PAUSE}s...`)
		task.wait(Constants.WAVE_PAUSE)
	end

	CombatSystem.Stop()
	print(`[GameLoop] üèÅ Partie termin√©e √† la vague {currentWave}`)
end)
