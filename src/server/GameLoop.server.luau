--!strict

--[[
	GameLoop (ServerScript)
	Tower Defense temps rÃ©el â€” SystÃ¨me de niveaux + vagues + Ã©conomie BrainCoin.
	Placement via plaques Touched sur le mur.
	Chaque niveau a un nombre limitÃ© de vagues et des paramÃ¨tres de difficultÃ©.
	Accessible depuis : ServerScriptService.Server.GameLoop
]]

-- Services
local Players: Players = game:GetService("Players")
local Workspace: Workspace = game:GetService("Workspace")
local ReplicatedStorage: ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Modules
local sharedFolder: Instance = ReplicatedStorage:WaitForChild("Shared")
local Constants = require(sharedFolder:WaitForChild("Constants"))
local BoardManager = require(script.Parent:WaitForChild("Systems"):WaitForChild("BoardManager"))
local UnitDatabase = require(sharedFolder:WaitForChild("Data"):WaitForChild("UnitDatabase"))
local ZombieSpawner = require(script.Parent:WaitForChild("Systems"):WaitForChild("ZombieSpawner"))
local CombatSystem = require(script.Parent:WaitForChild("Systems"):WaitForChild("CombatSystem"))
local LevelDatabase = require(sharedFolder:WaitForChild("Data"):WaitForChild("LevelDatabase"))
local PlayerInventory = require(script.Parent:WaitForChild("Systems"):WaitForChild("PlayerInventory"))
local GachaCatalog = require(sharedFolder:WaitForChild("Data"):WaitForChild("GachaCatalog"))

-- Initialiser le CombatSystem
CombatSystem.Init(BoardManager, ZombieSpawner)

-- RemoteEvents
local eventsFolder: Folder = sharedFolder:WaitForChild("Events") :: Folder
local budgetUpdateEvent: RemoteEvent = eventsFolder:WaitForChild("BudgetUpdate") :: RemoteEvent
local stateChangedEvent: RemoteEvent = eventsFolder:WaitForChild("StateChanged") :: RemoteEvent
local levelSelectEvent: RemoteEvent = eventsFolder:WaitForChild("LevelSelect") :: RemoteEvent
local gachaInfoEvent: RemoteEvent = eventsFolder:WaitForChild("GachaInfo") :: RemoteEvent

-- Constantes
local MIN_PLAYERS: number = 1
local PLATE_DEBOUNCE: number = 2  -- Secondes entre deux achats par joueur
local TOTAL_LEVELS: number = #LevelDatabase

-- RNG
local rng: Random = Random.new()

-------------------------------------------------
-- Ã‰tat du jeu
-------------------------------------------------
local playerBrainCoin: number = 0
local baseHP: number = Constants.BASE_HP
local currentLevel: number = 0
local currentWave: number = 0
local totalWavesInLevel: number = 0
local gameOver: boolean = false
local gameWon: boolean = false

-- Debounce par joueur+plaque ("UserId_UnitId" â†’ temps du dernier achat)
local plateDebounce: { [string]: number } = {}

-------------------------------------------------
-- Helpers
-------------------------------------------------

local function waitForPlayers(): ()
	print("[GameLoop] â³ En attente de joueurs...")
	while #Players:GetPlayers() < MIN_PLAYERS do
		task.wait(1)
	end
	print(`[GameLoop] âœ… {#Players:GetPlayers()} joueur(s) connectÃ©(s) â€” DÃ©marrage !`)
end

local function broadcastGameState(): ()
	budgetUpdateEvent:FireAllClients(playerBrainCoin, baseHP, currentLevel, currentWave, totalWavesInLevel)
end

local function broadcastLevelEvent(eventType: string, data: { [string]: any }?): ()
	stateChangedEvent:FireAllClients(eventType, data or {})
end

local function addBrainCoin(amount: number): ()
	playerBrainCoin += amount
	broadcastGameState()
end

-------------------------------------------------
-- Callbacks ZombieSpawner
-------------------------------------------------

local function getLevelData(): any
	if currentLevel >= 1 and currentLevel <= TOTAL_LEVELS then
		return LevelDatabase[currentLevel]
	end
	return nil
end

ZombieSpawner.OnZombieDied = function(zombie)
	local levelData = getLevelData()
	local reward: number = if levelData then levelData.KillReward else Constants.KILL_REWARD
	print(`[GameLoop] ğŸ’€ Zombie {zombie.UnitId} (ID:{zombie.Id}) tuÃ© ! +{reward} BrainCoin`)
	addBrainCoin(reward)
end

ZombieSpawner.OnZombieReachedEnd = function(zombie)
	baseHP -= zombie.Damage
	print(`[GameLoop] ğŸ  Base touchÃ©e ! -{zombie.Damage} HP â†’ {baseHP}/{Constants.BASE_HP}`)
	broadcastGameState()

	if baseHP <= 0 and not gameOver then
		gameOver = true
		warn(`[GameLoop] ğŸ’€ GAME OVER â€” La base est dÃ©truite ! (Niveau {currentLevel}, Vague {currentWave}/{totalWavesInLevel})`)
		broadcastLevelEvent("GameOver", {
			Level = currentLevel,
			Wave = currentWave,
		})
	end
end

-------------------------------------------------
-- Placement via Touched (plaques sur le mur)
-------------------------------------------------

--- Remonte l'arborescence pour trouver le Character (gÃ¨re Accessories)
local function getCharacterFromPart(part: BasePart): Model?
	local current: Instance? = part.Parent
	while current do
		if current:IsA("Model") and current:FindFirstChildOfClass("Humanoid") then
			return current :: Model
		end
		current = current.Parent
	end
	return nil
end

--- Connecte les Ã©vÃ©nements Touched sur les 4 plaques d'achat
local function setupPlates(): ()
	local gameBoard: Folder = Workspace:WaitForChild("GameBoard") :: Folder

	for _, unitId: string in Constants.PLANT_UNITS do
		local plateName: string = `Plate_{unitId}`
		local plate: Part? = gameBoard:FindFirstChild(plateName) :: Part?
		if plate == nil then
			warn(`[GameLoop] âš ï¸ Plaque introuvable : {plateName}`)
			continue
		end

		plate.Touched:Connect(function(otherPart: BasePart): ()
			if gameOver or gameWon then return end

			-- Trouver le Character (gÃ¨re accessoires + body parts)
			local character: Model? = getCharacterFromPart(otherPart)
			if character == nil then return end

			local player: Player? = Players:GetPlayerFromCharacter(character)
			if player == nil then return end

			-- Debounce par joueur + plaque
			local debounceKey: string = `{player.UserId}_{unitId}`
			local now: number = tick()
			local lastBuy: number = plateDebounce[debounceKey] or 0
			if (now - lastBuy) < PLATE_DEBOUNCE then return end

			-- VÃ©rifier donnÃ©es de l'unitÃ©
			local unitData = UnitDatabase[unitId]
			if unitData == nil then
				warn(`[GameLoop] âš ï¸ UnitDatabase["{unitId}"] introuvable`)
				return
			end

			-- VÃ©rifier que le joueur possÃ¨de l'unitÃ© (inventaire Gacha)
			if not PlayerInventory.OwnsUnit(player, unitId) then
				print(`[GameLoop] ğŸ”’ {player.Name} ne possÃ¨de pas {unitData.Name}`)
				return
			end

			-- VÃ©rifier BrainCoin
			local cost: number = unitData.Cost
			if playerBrainCoin < cost then
				print(`[GameLoop] âŒ BrainCoin insuffisant pour {unitData.Name} : {playerBrainCoin}/{cost}`)
				return
			end

			-- Debounce activÃ©
			plateDebounce[debounceKey] = now

			-- DÃ©duire le coÃ»t
			playerBrainCoin -= cost
			broadcastGameState()

			-- Position de spawn sur le sol (alÃ©atoire dans la zone)
			local spawnX: number = Constants.WALL_POSITION.X + rng:NextNumber(
				-Constants.UNIT_SPAWN_X_SPREAD,
				Constants.UNIT_SPAWN_X_SPREAD
			)
			local spawnZ: number = rng:NextNumber(
				Constants.UNIT_SPAWN_Z_MIN,
				Constants.UNIT_SPAWN_Z_MAX
			)
			local spawnPos: Vector3 = Vector3.new(spawnX, Constants.GROUND_TOP_Y, spawnZ)

			print(`[GameLoop] ğŸ”§ Spawn {unitData.Name} Ã  ({math.floor(spawnX)}, {Constants.GROUND_TOP_Y}, {math.floor(spawnZ)})`)

			-- Placer l'unitÃ© sur le sol (clone depuis Assets)
			local unitIdResult: number = BoardManager.PlaceUnit(unitId, spawnPos, player)

			if unitIdResult < 0 then
				-- Rembourser si Ã©chec
				playerBrainCoin += cost
				broadcastGameState()
				warn(`[GameLoop] âŒ Ã‰chec placement {unitData.Name}`)
				return
			end

			print(`[GameLoop] ğŸ§  {unitData.Name} achetÃ© ! BrainCoin restant : {playerBrainCoin} (-{cost})`)
		end)

		print(`[GameLoop] ğŸ”— Plaque connectÃ©e : {plateName}`)
	end
end

-------------------------------------------------
-- SystÃ¨me de vagues par niveau
-------------------------------------------------

local function spawnWave(levelData: any, waveNumber: number): ()
	local zombieCount: number = levelData.BaseZombieCount + (waveNumber - 1) * levelData.ZombieIncrement
	local isBossWave: boolean = (levelData.BossWave ~= nil and waveNumber == levelData.BossWave)

	print(`[GameLoop] ğŸŒŠ NIVEAU {currentLevel} â€” VAGUE {waveNumber}/{totalWavesInLevel} â€” {zombieCount} zombie(s){if isBossWave then " + BOSS!" else ""}`)

	-- Notifier les clients
	broadcastLevelEvent("WaveStart", {
		Level = currentLevel,
		Wave = waveNumber,
		TotalWaves = totalWavesInLevel,
		ZombieCount = zombieCount,
		IsBossWave = isBossWave,
	})

	local pool: { string } = levelData.ZombiePool

	for i = 1, zombieCount do
		if gameOver then break end

		-- Choisir un type de zombie alÃ©atoire dans le pool du niveau
		local zombieType: string = pool[rng:NextInteger(1, #pool)]
		ZombieSpawner.SpawnZombie(zombieType)

		if i < zombieCount then
			task.wait(levelData.WaveSpawnInterval)
		end
	end

	-- Spawner le boss en dernier si c'est la vague boss
	if isBossWave and levelData.BossType and not gameOver then
		task.wait(levelData.WaveSpawnInterval)
		local bossHP: number = math.ceil(
			(UnitDatabase[levelData.BossType] and UnitDatabase[levelData.BossType].HP or 10)
			* levelData.HPMultiplier
			* (levelData.BossHPMultiplier or 2.0)
		)
		ZombieSpawner.SpawnZombie(levelData.BossType, nil, bossHP)
		print(`[GameLoop] ğŸ‘¹ BOSS {levelData.BossType} spawnÃ© avec {bossHP} HP !`)
	end
end

local function waitForWaveEnd(): ()
	while ZombieSpawner.GetActiveCount() > 0 and not gameOver do
		task.wait(0.5)
	end
end

local function runLevel(levelNumber: number): boolean
	local levelData = LevelDatabase[levelNumber]
	if levelData == nil then
		warn(`[GameLoop] âŒ Niveau {levelNumber} introuvable dans LevelDatabase`)
		return false
	end

	currentLevel = levelNumber
	totalWavesInLevel = levelData.WaveCount
	currentWave = 0

	-- Configurer les multiplicateurs du niveau sur le ZombieSpawner
	ZombieSpawner.SetMultipliers(
		levelData.HPMultiplier,
		levelData.SpeedMultiplier,
		levelData.DamageMultiplier
	)

	-- Donner le BrainCoin de dÃ©part du niveau
	playerBrainCoin = levelData.StartingBrainCoin
	baseHP = Constants.BASE_HP

	print(`\n[GameLoop] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`)
	print(`[GameLoop] ğŸ° NIVEAU {levelNumber} : {levelData.Theme} {levelData.Name}`)
	print(`[GameLoop]    Vagues : {levelData.WaveCount} | Zombies : {levelData.BaseZombieCount}+{levelData.ZombieIncrement}/vague`)
	print(`[GameLoop]    HPÃ—{levelData.HPMultiplier}  SpeedÃ—{levelData.SpeedMultiplier}  DmgÃ—{levelData.DamageMultiplier}`)
	print(`[GameLoop]    BrainCoin de dÃ©part : {levelData.StartingBrainCoin}`)
	print(`[GameLoop] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`)

	-- Notifier les clients du dÃ©but du niveau
	broadcastLevelEvent("LevelStart", {
		Level = levelNumber,
		Name = levelData.Name,
		Theme = levelData.Theme,
		TotalWaves = levelData.WaveCount,
		TotalLevels = TOTAL_LEVELS,
	})
	broadcastGameState()

	-- Pause avant la premiÃ¨re vague
	print(`[GameLoop] â³ PremiÃ¨re vague dans 5 secondes...`)
	task.wait(5)

	-- Boucle des vagues du niveau
	for wave = 1, levelData.WaveCount do
		if gameOver then return false end

		currentWave = wave
		broadcastGameState()

		spawnWave(levelData, wave)
		waitForWaveEnd()

		if gameOver then return false end

		-- Vague terminÃ©e !
		print(`[GameLoop] ğŸ† Vague {wave}/{levelData.WaveCount} terminÃ©e ! +{levelData.WaveBonus} BrainCoin bonus`)
		addBrainCoin(levelData.WaveBonus)

		broadcastLevelEvent("WaveComplete", {
			Level = levelNumber,
			Wave = wave,
			TotalWaves = levelData.WaveCount,
		})

		-- Pause entre les vagues (sauf aprÃ¨s la derniÃ¨re)
		if wave < levelData.WaveCount then
			print(`[GameLoop] â¸ï¸ Prochaine vague dans {levelData.WavePause}s...`)
			task.wait(levelData.WavePause)
		end
	end

	-- Niveau terminÃ© !
	return true
end

-------------------------------------------------
-- Boucle principale â€” Attend la sÃ©lection de niveau
-------------------------------------------------
print("[GameLoop] ğŸ® GameLoop dÃ©marrÃ©e (SÃ©lection de niveaux)")

-- Ã‰tat de la file d'attente de sÃ©lection
local selectedLevel: number? = nil
local waitingForSelection: boolean = false

-- Connexion plaques faite une seule fois
local platesSetup: boolean = false

-- Ã‰couter la sÃ©lection de niveau par un joueur
levelSelectEvent.OnServerEvent:Connect(function(player: Player, levelNumber: unknown)
	local lv: number = if typeof(levelNumber) == "number" then math.floor(levelNumber) else 0
	if lv < 1 or lv > TOTAL_LEVELS then return end
	if not waitingForSelection then return end

	selectedLevel = lv
	print(`[GameLoop] ğŸ“© {player.Name} a choisi le niveau {lv}`)
end)

task.spawn(function(): ()
	-- Attendre qu'au moins un joueur soit connectÃ©
	waitForPlayers()

	-- Connecter les plaques d'achat (une seule fois)
	if not platesSetup then
		setupPlates()
		platesSetup = true
	end

	-- DÃ©marrer le CombatSystem
	CombatSystem.Start()

	-- Boucle : attendre sÃ©lection â†’ jouer niveau â†’ retour
	while true do
		-- Reset Ã©tat
		gameOver = false
		gameWon = false
		selectedLevel = nil
		waitingForSelection = true
		currentLevel = 0
		currentWave = 0
		totalWavesInLevel = 0

		print("[GameLoop] â³ En attente de sÃ©lection de niveau...")

		-- Attendre qu'un joueur sÃ©lectionne un niveau
		while selectedLevel == nil do
			task.wait(0.5)
		end
		waitingForSelection = false

		local chosenLevel: number = selectedLevel :: number
		print(`[GameLoop] ğŸ¯ Niveau {chosenLevel} sÃ©lectionnÃ© â€” Lancement !`)

		-- Notification
		broadcastLevelEvent("LevelSelected", {
			Level = chosenLevel,
			Name = LevelDatabase[chosenLevel].Name,
			Theme = LevelDatabase[chosenLevel].Theme,
		})

		-- Petite pause pour laisser le joueur arriver sur le mur
		task.wait(2)

		-- Lancer le niveau
		local success: boolean = runLevel(chosenLevel)

		if success and not gameOver then
			print(`[GameLoop] âœ… NIVEAU {chosenLevel} TERMINÃ‰ !`)

			-- RÃ©compense GachaTokens
			local tokenReward: number = GachaCatalog.TokenRewards[chosenLevel] or 1
			for _, p in Players:GetPlayers() do
				PlayerInventory.AddTokens(p, tokenReward)
				local newBalance: number = PlayerInventory.GetTokens(p)
				gachaInfoEvent:FireClient(p, { Tokens = newBalance })
				print(`[GameLoop] ğŸ« {p.Name} reÃ§oit {tokenReward} GachaToken(s) â†’ {newBalance}`)
			end

			broadcastLevelEvent("LevelComplete", {
				Level = chosenLevel,
				TotalLevels = TOTAL_LEVELS,
			})

			-- Pause avant retour au menu
			task.wait(8)
		elseif gameOver then
			-- Pause aprÃ¨s game over avant retour au menu
			task.wait(8)
		end

		-- Nettoyer les zombies restants
		for id, _ in ZombieSpawner.ActiveZombies do
			ZombieSpawner.DestroyZombie(id)
		end

		-- TÃ©lÃ©porter tous les joueurs au hub
		local HUB_RETURN_POS: Vector3 = Constants.SPAWN_CENTER + Vector3.new(0, 3, 15)
		for _, p in Players:GetPlayers() do
			local character = p.Character
			if character then
				local hrp = character:FindFirstChild("HumanoidRootPart") :: BasePart?
				if hrp then
					hrp.CFrame = CFrame.new(HUB_RETURN_POS)
				end
			end
		end

		-- Notifier le retour au menu
		broadcastLevelEvent("ReturnToMenu", {})
		print("[GameLoop] ğŸ”„ Retour au menu de sÃ©lection de niveau")
	end
end)
